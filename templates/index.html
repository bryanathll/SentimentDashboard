<!DOCTYPE html>
<html lang="en">
{% include "includes/head.html" %}

<body>

    <!-- use HTMX -->
    <!-- <div class="row text-center">
        <div class="col-lg-12">
            <h1>Sentiment Analysis Crawler</h1>
            <form id="crawl-form" hx-post="/" hx-target="#crawl-form" hx-swap="outerHTML">
                <label for="package_name">package_name</label>
                <input type="text" name="package_name" required>
                <button type="submit" hx-indicator="true">Crawl</button>
            </form>
        </div>
    </div>
    <div x-data="sentimentApp()" x-init="fetchAndPredict()" class="container">
        <div class="row">
            <div class="col-lg-12 mt-3">
                <div x-show="loading" class="loading-indicator">Loading sentiments...</div>

                {{table|safe}}
            </div>
        </div>
    </div> -->
    <!-- use HTMX -->

    <!-- not using HTMX -->
    <div class="row text-center">
        <div class="col-lg-12">
            <h1>Sentiment Analysis Crawler</h1>
            <form action="/" method="post">
                <label for="package_name">Package Name</label>
                <input type="text" name="package_name" required />
                <button type="submit">Crawl</button>
            </form>
        </div>
    </div>

    <div x-data="sentimentApp()" x-init="fetchAndPredict()" class="container">
        <div class="row">
            <div class="col-lg-12 mt-3">
                <div x-show="loading" class="loading-indicator">Loading sentiments...</div>

                {{ table|safe }}
            </div>
        </div>
    </div>
    <!-- not using HTMX -->

    <script>
        function sentimentApp() {
            return {
                loading: false, // Loading state indicator

                reviews: [],
                fetchAndPredict() {
                    this.loading = true;
                    this.$nextTick(() => {
                        const reviewsTable = document.querySelector(".table");
                        const reviewTexts = [...reviewsTable.querySelectorAll("tr")].slice(1).map((tr) => {
                            return tr.children[2].innerText; // Assuming the review text is the third column
                        });

                        // Call your API endpoint with the texts for sentiment analysis
                        fetch("/api/predict", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ texts: reviewTexts }),
                        })
                            .then((response) => response.json())
                            .then((data) => {
                                this.updateTableWithSentiments(reviewsTable, data.data.sentiments);
                                this.loading = false;
                            });
                    });
                },

                updateTableWithSentiments(reviewsTable, sentiments) {
                    // Add a new column header for Sentiments if not added yet
                    const headerRow = reviewsTable.querySelector("tr");
                    if (headerRow.querySelectorAll("th").length === 4) {
                        // Assuming there are originally 4 columns
                        const sentimentTh = document.createElement("th");
                        sentimentTh.innerText = "Sentiment";
                        headerRow.appendChild(sentimentTh);
                    }

                    // Update each row with the sentiment analysis result
                    const rows = [...reviewsTable.querySelectorAll("tr")].slice(1); // Exclude the header row
                    rows.forEach((tr, index) => {
                        // Extract the sentiment label and score from the API response
                        // Each result is an array with one object, so we access the first element.
                        const sentimentResult = sentiments[index][0]; // Get the first item of the nested array
                        const sentimentText = `${sentimentResult.label} (${sentimentResult.score.toFixed(2)})`;

                        // Check if sentiment cell already exists; if not, create it
                        if (tr.children.length === 4) {
                            // Assuming there are originally 4 columns
                            const sentimentTd = document.createElement("td");
                            sentimentTd.innerText = sentimentText;
                            tr.appendChild(sentimentTd);
                        } else {
                            // Update existing sentiment cell
                            tr.children[4].innerText = sentimentText;
                        }
                    });
                },
            };
        }
    </script>

</body>

</html>